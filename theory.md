Билет №20:
1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
2.  Основные методы для работы с коллекциями. Классы Collections, Arrays.
3.  Реализуйте программу на Java, которая считает медиану чисел. Реализовать клиент и сервер (сокеты). 
Клиент отправляет набор чисел, сервер принимает запрос от клиента, высчитывает медиану и 
отправляет обратно запросившему клиенту и дальше ждет новых запросов от клиента.,


# 1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.


Многопоточность — это технология, позволяющая выполнять несколько потоков одновременно.

Thread (поток) — это базовый элемент многопоточности. Потоки выполняются внутри одного процесса и используют его ресурсы.

Основные характеристики потоков в Java:
- Главный поток начинает выполнение программы через метод `main`.
- Дополнительные (дочерние) потоки могут создаваться для выполнения задач параллельно.
- Потоки одного процесса могут обмениваться данными друг с другом.
- Процесс завершает свою работу только после завершения всех его потоков (кроме потоков-демонов).

### Класс `Thread`

`Thread` — это основной класс для работы с потоками в Java. Создать поток можно двумя способами:

1. Наследование от класса `Thread`:
    - Переопределите метод `run()` для описания логики выполнения.

   Пример:
   ```java
   public class MyThread extends Thread {
       @Override
       public void run() {
           for (int i = 0; i < 5; i++) {
               System.out.println("Поток: " + i);
           }
       }
   }

   public static void main(String[] args) {
       MyThread thread = new MyThread();
       thread.start(); // Запуск нового потока
   }
   ```

2. Реализация интерфейса `Runnable`:
    - Создайте класс, реализующий `Runnable`, и передайте его объект в конструктор `Thread`.

   Пример:
   ```java
   Runnable task = () -> {
       for (int i = 0; i < 5; i++) {
           System.out.println("Поток: " + i);
       }
   };

   Thread thread = new Thread(task);
   thread.start();
   ```

### Интерфейсы `Runnable` и `Callable`

#### `Runnable`:
Runnable — это функциональный интерфейс, представляющий задачу, которая не возвращает результат. 
Он чаще всего используется для простых задач, не требующих возврата данных или обработки исключений.

- Метод: `void run()`.
- Не возвращает результата.
- Не выбрасывает проверяемых исключений.

Пример:
```java
Runnable task = () -> System.out.println("Задача выполняется");
Thread thread = new Thread(task);
thread.start();
```

#### `Callable`:
Callable — это функциональный интерфейс, представляющий задачу, которая возвращает результат 
и может выбрасывать проверяемые исключения.

- Метод: `V call()`.
- Возвращает результат выполнения задачи (`V` — тип результата).
- Может выбрасывать проверяемые исключения.

Пример:
```java
Callable<Integer> task = () -> {
    Thread.sleep(1000); 
    return 42;
};
```


### Состояния потока

Потоки в Java могут находиться в следующих состояниях:

1. NEW: Поток создан, но еще не запущен.
2. RUNNABLE: Поток готов к выполнению, но может ожидать процессор.
3. BLOCKED: Поток ждет доступа к монитору (например, при синхронизации).
4. WAITING: Поток ждет уведомления от другого потока.
5. TIMED_WAITING: Поток ждет события в течение заданного времени (например, через `sleep()`).
6. TERMINATED: Поток завершил выполнение.

---

### Интерфейс `Future`

`Future` — это интерфейс, представляющий результат асинхронной задачи. Он используется для управления задачами, которые выполняются в отдельных потоках.

#### Основные методы `Future`

| Метод                                | Описание                                                                                     |
|--------------------------------------|---------------------------------------------------------------------------------------------|
| `get()`                          | Возвращает результат выполнения задачи. Блокирует поток, пока задача не завершится.         |
| `get(long timeout, TimeUnit unit)`| Возвращает результат задачи, ожидая не дольше указанного времени.                           |
| `isDone()`                       | Проверяет, завершена ли задача.                                                            |
| `isCancelled()`                  | Проверяет, была ли задача отменена.                                                        |
| `cancel(boolean mayInterruptIfRunning)` | Пытается отменить задачу. Возвращает `true`, если отмена успешна.                         |

---

#### Использование `Future`

Пример работы с `Future`:

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<Integer> task = () -> {
            Thread.sleep(2000); 
            return 42;
        };

        Future<Integer> future = executor.submit(task);

        try {
            System.out.println("Результат: " + future.get()); 
        } catch (InterruptedException | ExecutionException e) {
            System.err.println("Ошибка выполнения задачи: " + e.getMessage());
        } finally {
            executor.shutdown();
        }
    }
}
```

### Отмена задач с использованием `Future`

Задачу можно отменить, если она еще не завершена:

```java
if (!future.isDone()) {
    boolean canceled = future.cancel(true); // Прерывание задачи
    System.out.println("Задача отменена: " + canceled);
}
```

---

### Плюсы `Future`

1. Асинхронное выполнение задач.
2. Удобный способ получить результат выполнения задачи.
3. Интеграция с `ExecutorService`.

---

### Минусы `Future`

1. Нет автоматического уведомления о завершении задачи — необходимо вручную проверять `isDone` или использовать `get()`.
2. Неудобно объединять несколько асинхронных задач.


# 2.  Основные методы для работы с коллекциями. Классы Collections, Arrays.

### Класс `Collections`

Класс `Collections` из пакета `java.util` предоставляет набор статических методов для работы с коллекциями.
Он работает с объектами, реализующими интерфейсы `Collection`, такие как `List`, `Set`, `Map`.

#### Основные методы класса `Collections`

| Метод                                    | Описание                                                                                       |
|------------------------------------------|-----------------------------------------------------------------------------------------------|
| `sort(List<T>)`                      | Сортирует элементы списка по естественному порядку или с использованием компаратора.          |
| `reverse(List<T>)`                   | Разворачивает порядок элементов в списке.                                                    |
| `shuffle(List<T>)`                   | Перемешивает элементы списка случайным образом.                                               |
| `max(Collection<T>)`                 | Возвращает максимальный элемент коллекции по естественному порядку или компаратору.           |
| `min(Collection<T>)`                 | Возвращает минимальный элемент коллекции.                                                    |
| `binarySearch(List<T>, T)`           | Выполняет бинарный поиск элемента в отсортированном списке.                                   |
| `frequency(Collection<T>, T)`        | Возвращает количество вхождений элемента в коллекцию.                                         |
| `disjoint(Collection<?> c1, Collection<?> c2)` | Проверяет, не имеют ли коллекции общих элементов.                                             |
| `copy(List<T> dest, List<T> src)`    | Копирует элементы из одного списка в другой.                                                  |
| `fill(List<T>, T obj)`               | Заполняет список указанным элементом.                                                        |
| `nCopies(int n, T obj)`              | Создает неизменяемый список из `n` копий указанного элемента.                                 |
| `synchronizedList(List<T>)`          | Возвращает потокобезопасную версию списка.                                                   |
| `unmodifiableList(List<T>)`          | Возвращает неизменяемую версию списка.                                                       |

#### Пример использования класса `Collections`

```java
import java.util.*;

public class CollectionsExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 3, 9));

        Collections.sort(numbers);
        System.out.println("Отсортированный список: " + numbers);

        Collections.shuffle(numbers);
        System.out.println("Перемешанный список: " + numbers);

        System.out.println("Максимум: " + Collections.max(numbers));
        System.out.println("Минимум: " + Collections.min(numbers));

        Collections.fill(numbers, 42);
        System.out.println("Список после заполнения: " + numbers);
    }
}
```

### Класс `Arrays`

Класс `Arrays` из пакета `java.util` предоставляет набор методов для работы с массивами.

#### Основные методы класса `Arrays`

| Метод                                    | Описание                                                                                       |
|------------------------------------------|-----------------------------------------------------------------------------------------------|
| `sort(T[] array)`                    | Сортирует элементы массива по естественному порядку или с использованием компаратора.          |
| `binarySearch(T[] array, T key)`     | Выполняет бинарный поиск элемента в отсортированном массиве.                                   |
| `equals(T[] a1, T[] a2)`             | Проверяет, равны ли массивы по элементам.                                                     |
| `copyOf(T[] original, int newLength)`| Создает новый массив, копируя элементы исходного массива.                                      |
| `toString(T[] array)`                | Возвращает строковое представление массива.                                                   |
| `asList(T... array)`                 | Преобразует массив в список фиксированной длины.                                              |
| `fill(T[] array, T value)`           | Заполняет массив указанным элементом.                                                         |
| `stream(T[] array)`                  | Преобразует массив в поток (Stream API).                                                      |
| `parallelSort(T[] array)`            | Сортирует массив параллельно, используя несколько потоков.                                     |

#### Пример использования класса `Arrays`

```java
import java.util.Arrays;

public class ArraysExample {
    public static void main(String[] args) {
        int[] array = {5, 2, 8, 3, 9};

        Arrays.sort(array);
        System.out.println("Отсортированный массив: " + Arrays.toString(array));

        int index = Arrays.binarySearch(array, 8);
        System.out.println("Индекс числа 8: " + index);

        int[] copiedArray = Arrays.copyOf(array, 7); 
        System.out.println("Скопированный массив: " + Arrays.toString(copiedArray));

        Arrays.fill(copiedArray, 42);
        System.out.println("Массив после заполнения: " + Arrays.toString(copiedArray));
    }
}
```

### Сравнение классов `Collections` и `Arrays`

| Особенность             | `Collections`                                  | `Arrays`                                      |
|--------------------------|-----------------------------------------------|-----------------------------------------------|
| Основное назначение      | Работа с коллекциями (`List`, `Set`, `Map`)   | Работа с массивами (`T[]`)                   |
| Типы данных             | Только коллекции                              | Только массивы                               |
| Часто используемые методы| `sort`, `shuffle`, `max`, `min`, `frequency`  | `sort`, `binarySearch`, `copyOf`, `fill`     |
| Потокобезопасность       | Поддержка синхронизации (`synchronizedList`)  | Не поддерживает потокобезопасность           |

