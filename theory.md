Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.

интерфейс AutoCloseable позволяет генерировать исключения любого типа с помощью метода close(), в котором описывается
логика освобождения ресурсов.

Неконтроллируемые ресурсы — это ресурсы, которые не управляются JVM напрямую и требуют явного освобождения программой. К
таким ресурсам относятся:

- Файловые дескрипторы: Работа с файлами, директориями.
- Сетевые соединения: Соединения по протоколам TCP/IP, UDP и другие.
- Базы данных: Соединения с базами данных через JDBC.
- Потоки ввода-вывода: InputStream, OutputStream, Reader, Writer и их производные.
- Сокеты: Socket, ServerSocket и т.д.
- Драйверы графических устройств: Например, в графических приложениях.

Проблема: Если такие ресурсы не освобождены после использования,
это может привести к утечкам ресурсов, снижению производительности и даже сбоям приложения.

AutoCloseable — это интерфейс из пакета java.lang, введенный в Java 7. Он
предоставляет механизм для автоматического освобождения ресурсов после их использования.

public interface AutoCloseable {
//Метод вызывается автоматически после выхода из блока try, который
//использует ресурс, реализующий этот интерфейс.
//@throws Exception Если возникает исключение при закрытии ресурса.
void close() throws Exception;
}

Цель интерфейса AutoCloseable

- Унификация: Позволяет любому классу, управляющему ресурсами, быть использованным в конструкции try-with-resources.
- Безопасность: Обеспечивает гарантированное закрытие ресурсов, даже если в блоке try возникает исключение.
- Простота: Упрощает написание кода для управления ресурсами.

Классы, реализующие AutoCloseable

Многие стандартные классы Java, которые управляют ресурсами, реализуют AutoCloseable:

- FileInputStream, FileOutputStream
- BufferedReader, BufferedWriter
- Connection (из JDBC)
- Statement и ResultSet (из JDBC)
- Scanner
- Пользовательские классы, управляющие ресурсами

Пример
public class MyResource implements AutoCloseable {
public MyResource() {
System.out.println("Ресурс открыт");
}

    public void doSomething() {
        System.out.println("Ресурс используется");
    }

    @Override
    public void close() {
        System.out.println("Ресурс закрыт");
    }

}

public class AutoCloseableExample {
public static void main(String[] args) {
try (MyResource resource = new MyResource()) {
resource.doSomething();
}
}
}

Конструкция try-with-resources
try (ресурс1; ресурс2; ...) {
// Использование ресурсов
} catch (Исключение e) {
// Обработка исключений
} finally {
// Дополнительная очистка (опционально)
}

try-with-resources — это конструкция, введенная в Java 7, которая автоматически управляет ресурсами, реализующими
интерфейс AutoCloseable (или его подинтерфейс Closeable). Эта конструкция гарантирует, что ресурсы будут закрыты
автоматически при выходе из блока try, независимо от того, возникло там исключение или нет.

Если в блоке try возникает одно исключение, а при закрытии ресурсов — другое, то второе исключение добавляется как
подчинённое (suppressed) к первому. Это позволяет сохранить информацию обо всех возникающих проблемах.

До введения конструкции try-with-resources и интерфейса AutoCloseable, для освобождения ресурсов использовался метод
finalize класса Object.

Назначение метода finalize

- Освобождение ресурсов: Позволял разработчикам определить логику освобождения ресурсов перед сборкой мусора объекта.
- Очистка: Возможно использование для освобождения нежелательных ресурсов или выполнения действий перед уничтожением
  объекта.

Проблемы метода finalize

1. Непредсказуемость: Время вызова метода finalize не гарантировано, поскольку зависит от работы сборщика мусора.
2. Низкая производительность: Сборщик мусора тратит дополнительные ресурсы на вызов finalize.
3. Ненадёжность: Если объект отклоняет исключение в finalize, это может привести к прекращению вызовов finalize для
   этого и других объектов.
4. Зависимость от сборщика мусора: Необходимо полагаться на сборщик мусора для освобождения ресурсов, что противоречит
   принципу явного управления ресурсами.
5. Депрецированный: Начиная с Java 9, метод finalize объявлен устаревшим (deprecated) и его использование не
   рекомендуется.

Пример:
public class FinalizeExample {
@Override
protected void finalize() throws Throwable {
try {
// Освобождение ресурса
System.out.println("Finalize: Ресурс освобожден");
} finally {
super.finalize();
}
}

    public static void main(String[] args) {
        FinalizeExample example = new FinalizeExample();
        example = null; // Делаем объект доступным для сборки мусора

        // Запускаем сборщик мусора
        System.gc();

        // Ожидание для демонстрации вызова finalize
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Конец программы");
    }

}

Класс ArrayDeque. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.




- ArrayDeque<E> — это двусторонняя очередь (deque), реализованная на основе массива.
- Является частью java.util и реализует интерфейсы `Deque<E>`, `Queue<E>`, `Iterable<E>`.
- Поддерживает операции вставки и удаления элементов как с головы, так и с хвоста.
- Быстрее `LinkedList` при использовании в качестве стека или очереди, так как не требует дополнительных затрат на хранение связей между узлами.
- Не поддерживает `null`-элементы.

реализации:

`ArrayDeque` использует массив в качестве внутреннего хранилища.
- Начальный размер массива — 16 (или ближайшая степень двойки).
- Динамически расширяется в два раза при нехватке места.
- Использует кольцевой буфер, что позволяет эффективно управлять элементами без затрат на сдвиги.


вставка:
- `addFirst(E e)`, `offerFirst(E e)`: добавляют элемент в начало.
- `addLast(E e)`, `offerLast(E e)`: добавляют элемент в конец.

Пример работы:
```java
ArrayDeque<Integer> deque = new ArrayDeque<>();
deque.addFirst(10); // [10]
deque.addLast(20);  // [10, 20]
deque.offerFirst(5); // [5, 10, 20]
```

суть работы:
Вычисляется индекс, куда вставить (head/tail).
Если массив заполнен, создаётся новый массив большего размера.
Элемент добавляется, `head` или `tail` обновляется.

удаление:
- `removeFirst()`, `pollFirst()`: удаляют элемент с начала.
- `removeLast()`, `pollLast()`: удаляют элемент с конца.

Пример работы:
```java
System.out.println(deque.pollFirst()); // 5, очередь теперь [10, 20]
System.out.println(deque.pollLast());  // 20, очередь теперь [10]
```

принцип работы:
Берётся элемент по `head` или `tail`.
Значение заменяется `null`, указатель `head` или `tail` сдвигается.
Если массив сильно разрежен, может выполняться уменьшение размера.

поиск:
- `contains(Object o)`: проверяет, есть ли элемент в очереди.

Пример:
```java
System.out.println(deque.contains(10)); // true
```

принцип работы:
Итерируемся по массиву, сравнивая элементы.
Временная сложность — `O(n)`.

сложность:
- Вставка/удаление `O(1)`, если не требуется расширение.
- Поиск `O(n)`, так как `ArrayDeque` не поддерживает индексацию.

- Если нужна очередь или стек с быстрой работой на вставку/удаление.
- Когда важна производительность (быстрее `LinkedList`).
- Когда не требуется поиск по индексу (`ArrayList` лучше в этом случае).